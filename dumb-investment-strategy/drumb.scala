// Part 2 and 3 about a really dumb investment strategy
//======================================================


//two test portfolios

val blchip_portfolio = List("GOOG", "AAPL", "MSFT", "IBM", "FB", "AMZN", "BIDU")
val rstate_portfolio = List("PLD", "PSA", "AMT", "AIV", "AVB", "BXP", "CCI", 
                            "DLR", "EQIX", "EQR", "ESS", "EXR", "FRT", "HCP") 


// (1) The function below takes a stock symbol and a year as arguments.
//     It should read the corresponding CSV-file and reads the January 
//     data from the given year. The data should be collected in a list of
//     strings for each line in the CSV-file.

import io.Source
import scala.util._


//For Part 2 + 3: useful string functions: .startsWith(...) for checking whether
//a string has a given prefix, _ ++ _ for concatenating two strings; useful option
//functions: .flatten flaĴens a list of options such that it filters way all None’s,
//Try(...).getOrElse ... runs some code that might raise an exception—if
//yes, then a default value can be given; useful list functions: .head for obtaining
//the first element in a non-empty list, .length for the length of a list; .filter(...)
//for filtering out elements in a list; .getLines.toList for obtaining a list of lines
//from a file; .split(",").toList for spliĴing strings according to a comma.
//Fortunately Scala supports operator overloading. But make sure you understand
//the difference between 100 / 3 and 100.0 / 3


def return_line(line: String, month : String, year: String) : Boolean = {
   if(line.split("-").length > 1){
        if(line.split("-")(1) == month && line.split("-")(0) == year)
            true
        else
            false
    }
    else false
}

def get_january_data(symbol: String, year: Int) : List[String] = {

   Try(
    Some(
            Source.fromFile(symbol ++ ".csv")
                .getLines.toList
                    .filter(
                        return_line(_ ,"01", year.toString)
                    )
                
            )
        )
        .getOrElse(None)
        .toList
        .flatten

}

// (2) From the output of the get_january_data function, the next function 
//     should extract the first line (if it exists) and the corresponding
//     first trading price in that year with type Option[Double]. If no line 
//     is generated by get_january_data then the result is None; Some if 
//     there is a price.


def get_first_price(symbol: String, year: Int) : Option[Double] = {
    Try(Some(get_january_data(symbol, year).head.split(",")(1).toDouble)).getOrElse(None)
}


// (3) Complete the function below that obtains all first prices
//     for the stock symbols from a portfolio (list of strings) and 
//     for the given range of years. The inner lists are for the
//     stock symbols and the outer list for the years.


def get_prices(portfolio: List[String], years: Range) : List[List[Option[Double]]] = {
    
        for( year <- years.toList) yield{
                for(stock <- portfolio)  yield{
                    get_first_price(stock , year)
                    }
        }
}

//==============================================
// Do not change anything below, unless you want 
// to submit the file for the advanced part 3!
//==============================================


// (4) The function below calculates the change factor (delta) between
//     a price in year n and a price in year n + 1. 

def get_delta(price_old: Option[Double], price_new: Option[Double]) : Option[Double] = (price_old, price_new) match  {
    case  (Some(po), Some(pn)) => Some((pn - po) / po)
    case _ => None
}



// (5) The next function calculates all change factors for all prices (from a 
//     portfolio). The input to this function are the nested lists created by 
//     get_prices above.

def get_deltas(data: List[List[Option[Double]]]) :  List[List[Option[Double]]] = {
val data_no_head = data.tail
    data_no_head.map( year => {
        year.map( company_share_price => {
                val index_previous_year =  data.indexOf(year) - 1
                val index_company = year.indexOf(company_share_price)
                val price_old = data(index_previous_year)(index_company)
               
                get_delta( price_old, company_share_price)
            })
        })
    }





// (6) Write a function that given change factors, a starting balance and an index,
//     calculates the yearly yield, i.e. new balance, according to our dumb investment 
//     strategy. Index points to a year in the data list.


def get_sum_of_year(year: List[Double]) : Long =
    year match{
        case x :: tail => (x.toLong+ get_sum_of_year(tail))
        case Nil => 0
    }

def yearly_yield(data: List[List[Option[Double]]], balance: Long, index: Int) : Long = {
    val year = data(index).flatten
    val balance_per_company = balance/year.length
    val evaluated_year =  year.map( company_factor => {
        company_factor * balance_per_company
    })
    get_sum_of_year(evaluated_year) + balance
}
 
//yearly_yield( get_deltas( get_prices (List("GOOG", "AAPL"), (2010 to 2012))), 100, 0)
// should be 125
//yearly_yield( get_deltas( get_prices (rstate_portfolio, ( 1978 to 2018))), 100, 0)
//CW6b.yearly_yield( CW6b.get_deltas( CW6b.get_prices (rstate_portfolio, ( 1978 to 2018))), 100, 0)
//96
//yearly_yield( get_deltas( get_prices (blchip_portfolio, ( 1978 to 2018))), 100, 0)
//CW6b.yearly_yield( CW6b.get_deltas( CW6b.get_prices (blchip_portfolio, ( 1978 to 2018))), 100, 0)
//117

// (7) Write a function compound_yield that calculates the overall balance for a 
//     range of years where in each year the yearly profit is compounded to the new 
//     balances and then re-invested into our portfolio. For this use the function and 
//     results generated under (6). The function investment calls compound_yield
//     with the appropriate deltas and the first index.


// def yearly_yield_double(data: List[List[Option[Double]]], balance: Double, index: Int) : Double = {
//     val year = data(index).flatten
//     val balance_per_company = balance/year.length
//     val evaluated_year =  year.map( company_factor => {
//         company_factor * balance_per_company
//     })
//     get_sum_of_year(evaluated_year) + balance
// }
// 
// 
// def compound_yield_double(data: List[List[Option[Double]]], balance: Double, index: Int) : Double = {
//    if(index >= data.length){
//         balance
//    }
//    else{
//         val new_balance = yearly_yield_double(data, balance, index)
//         compound_yield_double(data, new_balance, index+1)
//    }
// }
//  


def compound_yield(data: List[List[Option[Double]]], balance: Long, index: Int) : Long = {
   if(index >= data.length){
        balance
   }
   else{
        val new_balance = yearly_yield(data, balance, index)
        compound_yield(data, new_balance, index+1)
   }
}
    
def investment(portfolio: List[String], years: Range, start_balance: Long) : Long = {
    compound_yield(get_deltas(get_prices(portfolio, years)), start_balance, 0)
}




//Test cases for the two portfolios given above

//println("Real data: " + investment(rstate_portfolio, 1978 to 2018, 100))
//101589
//println("Blue data: " + investment(blchip_portfolio, 1978 to 2018, 100))
//1587528
//scala -cp drumb.jar

//println("Real data: " + CW6b.investment(rstate_portfolio, 1978 to 2018, 100))
//println("Real data: " + CW6b.investment(blchip_portfolio, 1978 to 2018, 100))

//get_deltas(get_prices(rstate_portfolio, 1978 to 2018)) //40